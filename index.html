<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ping View</title>
    <style>
        body {
            margin: 0;
            background-color: black;
            overflow: hidden;
        }

        #matrix {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #main {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 2;
        }

        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            animation: scanlines 0.1s linear infinite;
        }

        .crt-flicker {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            background: rgba(0, 255, 0, 0.02);
            animation: flicker 0.15s infinite;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.9);
        }

        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(2px); }
        }

        @keyframes flicker {
            0% { opacity: 0.97; }
            50% { opacity: 1; }
            100% { opacity: 0.98; }
        }
    </style>
</head>
<body>
<div class="scanline"></div>
<div class="crt-flicker"></div>
<canvas id="matrix"></canvas>
<canvas id="main"></canvas>
<script>
    const URL_PARAMS = new URLSearchParams(location.search)

    const MATRIX_CANVAS = document.getElementById('matrix')
    const MATRIX_CTX = MATRIX_CANVAS.getContext('2d')
    const C = document.getElementById('main')
    const CTX = C.getContext('2d', { alpha: true })

    MATRIX_CANVAS.width = innerWidth
    MATRIX_CANVAS.height = innerHeight
    C.width = innerWidth
    C.height = innerHeight

    let DEFAULT_CHAR_WIDTH = CTX.measureText('M').width
    const DEFAULT_CHAR_HEIGHT = 16
    const TEXT_BASELINE_OFFSET = 13

    const welcomeTitle = ` 
============================================================
          █                           █                 
   ██                        █████░                     
   ██                        █   ▓█                     
  ▒██▒  ███    █▒██▒         █    █ ███    █▒██▒   ██▓█ 
  ▓▒▒▓    █    █▓ ▒█         █   ▓█   █    █▓ ▒█  █▓ ▓█ 
  █░░█    █    █   █         █████░   █    █   █  █   █ 
  █  █    █    █   █         █        █    █   █  █   █ 
 ▒████▒   █    █   █         █        █    █   █  █   █ 
 ▓▒  ▒▓   █    █   █         █        █    █   █  █▓ ▓█ 
 █░  ░█ █████  █   █         █      █████  █   █   ██▒█ 
                                                      █ 
                                                   ▓ ▒█ 
                                                   ▒██░ 
============================================================
 `
    const WELCOMETITLE_LINE_CHARS = 60
    const CONTINUOUS_PING_TIMES = 6
    const ANIMATION_SPEED = 1
    // const VERSION = require('./package.json').version
    const VERSION = '0.3.1'
    const MIRROR_LIST = {
        'jp.livelog.nexon.com': 'http://jp.livelog.nexon.com:443',
        'Ain ch.1': 'http://18.176.79.10:8585',
        'Ain ch.2': 'http://3.112.119.155:8585',
        'Ain ch.3': 'http://52.197.194.155:8585',
        'Ain ch.4': 'http://35.79.26.6:8585',
        'Ain ch.5': 'http://54.64.47.212:8585',
        'Ain ch.6': 'http://54.64.47.212:8586',
        'Ain ch.7': 'http://35.75.33.109:8585',
        'Ain ch.8': 'http://35.75.33.109:8586',
        'Ain ch.9': 'http://57.181.203.81:8585',
        'Ain ch.10': 'http://57.181.203.81:8586',
        'Ain ch.11': 'http://54.65.159.42:8585',
        'Ain ch.12': 'http://54.65.159.42:8586',
        'Ain ch.13': 'http://18.177.179.145:8585',
        'Ain ch.14': 'http://18.177.179.145:8586',
        'Ain ch.15': 'http://13.115.72.186:8585',
        'Ain ch.16': 'http://13.115.72.186:8586',
        'Ain ch.17': 'http://13.114.24.162:8585',
        'Ain ch.18': 'http://13.114.24.162:8586',
        'Ain ch.19': 'http://57.182.28.187:8585',
        'Ain ch.20': 'http://57.182.28.187:8586',
    }

    let skipAnimation = false
    let writing = false

    let currentColumn = 1
    let currentLine = 1

    let frameRendered = 0

    const callFn = (fn) => fn()

    const getLatencyColor = (ms) => {
        if (ms >= 100) return '#f00'
        if (ms >= 50) return '#ff0'
        return '#0f0'
    }

    const MATRIX_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()_+-=[]{}|;:,.<>?'
    const COLUMN_DROPS = []
    const FONT_SIZE = 14

    const initMatrix = () => {
        const columns = Math.floor(MATRIX_CANVAS.width / FONT_SIZE)
        for (let i = 0; i < columns; i++) {
            COLUMN_DROPS[i] = Math.random() * -100
        }
    }

    const drawMatrix = () => {
        MATRIX_CTX.fillStyle = 'rgba(0, 0, 0, 0.05)'
        MATRIX_CTX.fillRect(0, 0, MATRIX_CANVAS.width, MATRIX_CANVAS.height)

        MATRIX_CTX.fillStyle = '#00f'
        MATRIX_CTX.font = `${FONT_SIZE}px monospace`

        for (let i = 0; i < COLUMN_DROPS.length; i++) {
            const text = MATRIX_CHARS.charAt(Math.floor(Math.random() * MATRIX_CHARS.length))
            const x = i * FONT_SIZE
            const y = COLUMN_DROPS[i] * FONT_SIZE

            MATRIX_CTX.fillStyle = `rgba(0, ${50 + Math.random() * 50}, ${150 + Math.random() * 105}, ${0.3 + Math.random() * 0.7})`
            MATRIX_CTX.fillText(text, x, y)

            if (y > MATRIX_CANVAS.height && Math.random() > 0.975) {
                COLUMN_DROPS[i] = 0
            }

            COLUMN_DROPS[i]++
        }
    }

    const animateMatrix = () => {
        drawMatrix()
        requestAnimationFrame(animateMatrix)
    }

    initMatrix()
    animateMatrix()

    const SCRAMBLE_CHARS = '!@#$%^&*()_+-=[]{}|;:,.<>?/~`'

    const encryptText = (text, progress) => {
        const scrambleLength = Math.floor((1 - progress) * text.length)
        const result = []
        for (let i = 0; i < text.length; i++) {
            if (i < text.length - scrambleLength) {
                result.push(text[i])
            } else {
                result.push(SCRAMBLE_CHARS.charAt(Math.floor(Math.random() * SCRAMBLE_CHARS.length)))
            }
        }
        return result.join('')
    }

    const drawChars = (
        text,
        x,
        y,
        textColor = '#0a0',
        cursorColor = '#fff',
        highlighColor = '#0f0',
        cursor = true,
        useGlow = false,
        isFirstCall = true
    ) => {
        x = x | 0
        y = y | 0

        const baselineY = y + TEXT_BASELINE_OFFSET
        const textX = x | 0
        const highlightX = (x + DEFAULT_CHAR_WIDTH) | 0
        const cursorX = highlightX

        if (isFirstCall) {
            const maxTextLength = 8
            CTX.clearRect(x, y, maxTextLength * DEFAULT_CHAR_WIDTH, DEFAULT_CHAR_HEIGHT)
        } else {
            CTX.clearRect(
                textX,
                y,
                DEFAULT_CHAR_WIDTH * 3 | 0,
                DEFAULT_CHAR_HEIGHT | 0
            )
        }

        if (cursor) {
            const cursorIntensity = 0.5 + Math.sin(Date.now() / 100) * 0.5
            CTX.fillStyle = `rgba(255, 255, 255, ${cursorIntensity})`
            CTX.fillRect(
                cursorX,
                baselineY - DEFAULT_CHAR_HEIGHT + 4,
                DEFAULT_CHAR_WIDTH - 4 | 0,
                DEFAULT_CHAR_HEIGHT - 12 | 0
            )
        }

        CTX.fillStyle = textColor
        CTX.fillText(text[0], textX, baselineY)
        text.shift()
        frameRendered++

        if (text.length === 0) {
            writing = false
            CTX.clearRect(
                cursorX,
                baselineY - DEFAULT_CHAR_HEIGHT + 4,
                DEFAULT_CHAR_WIDTH - 4 | 0,
                DEFAULT_CHAR_HEIGHT - 12 | 0
            )
            return [x, y, currentColumn, currentLine]
        }

        CTX.fillStyle = highlighColor
        CTX.fillText(text[0], highlightX, baselineY)

        if (frameRendered % ANIMATION_SPEED === 0 && !skipAnimation) {
            requestAnimationFrame(() =>
                drawChars(
                    text,
                    x + DEFAULT_CHAR_WIDTH,
                    y,
                    textColor,
                    cursorColor,
                    highlighColor,
                    cursor,
                    useGlow,
                    false
                )
            )
        } else {
            drawChars(
                text,
                x + DEFAULT_CHAR_WIDTH,
                y,
                textColor,
                cursorColor,
                highlighColor,
                cursor,
                useGlow,
                false
            )
        }
        return [x + DEFAULT_CHAR_WIDTH, y, currentColumn, currentLine]
    }

    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms))

    const _writeText = (
        text,
        x,
        y,
        textColor = '#0a0',
        cursorColor = '#fff',
        highlighColor = '#0f0',
        cursor = true,
        useEncryptEffect = false
    ) => {
        return new Promise((resolve) => {
                const startWriting = () => {
                    if (useEncryptEffect) {
                        let progress = 0
                        const encryptAnimation = () => {
                            progress += 0.15
                            const encrypted = encryptText(text, progress)

                            const maxTextLength = 8
                            CTX.clearRect(x, y, maxTextLength * DEFAULT_CHAR_WIDTH, DEFAULT_CHAR_HEIGHT)

                        CTX.fillStyle = highlighColor
                        CTX.fillText(encrypted, x, y + TEXT_BASELINE_OFFSET)

                        if (progress < 1) {
                            requestAnimationFrame(encryptAnimation)
                        } else {
                            const [finalX, finalY, c, l] = drawChars(
                                [...text],
                                x,
                                y,
                                textColor,
                                cursorColor,
                                highlighColor,
                                cursor,
                                false
                            )
                            resolve([finalX, finalY, currentColumn, currentLine])
                        }
                    }
                    encryptAnimation()
                } else {
                    const [finalX, finalY, c, l] = drawChars(
                        [...text],
                        x,
                        y,
                        textColor,
                        cursorColor,
                        highlighColor,
                        cursor,
                        false
                    )
                    resolve([finalX, finalY, currentColumn, currentLine])
                }
            }

            if (!writing) {
                writing = true
                startWriting()
            } else {
                requestAnimationFrame(() => {
                    _writeText(text, x, y, textColor, cursorColor, highlighColor, cursor, useEncryptEffect)
                        .then(resolve)
                })
            }
        })
    }

    const writeln = (
        text,
        textColor = '#0a0',
        cursorColor = '#fff',
        highlighColor = '#0f0',
        cursor = true
    ) => {
        currentColumn = 1
        currentLine++
        return write(text, textColor, cursorColor, highlighColor, cursor)
    }

    const writeKeepPos = (
        text,
        textColor = '#0a0',
        cursorColor = '#fff',
        highlighColor = '#0f0',
        cursor = true
    ) => {
        return _writeText(
            text,
            currentColumn * DEFAULT_CHAR_WIDTH,
            currentLine * DEFAULT_CHAR_HEIGHT,
            textColor,
            cursorColor,
            highlighColor,
            cursor
        )
    }

    const write = (
        text,
        textColor = '#0a0',
        cursorColor = '#fff',
        highlighColor = '#0f0',
        cursor = true
    ) => {
        const [x, y, c, l] = _writeText(
            text,
            currentColumn * DEFAULT_CHAR_WIDTH,
            currentLine * DEFAULT_CHAR_HEIGHT,
            textColor,
            cursorColor,
            highlighColor,
            cursor
        )
        currentColumn += text.length + 1
        return [x, y, currentColumn, currentLine]
    }

    const writeParcel = (
        text,
        textColor = '#0a0',
        cursorColor = '#fff',
        highlighColor = '#0f0',
        cursor = true
    ) => {
        const x = currentColumn * DEFAULT_CHAR_WIDTH
        const y = currentLine * DEFAULT_CHAR_HEIGHT
        drawChars(
            [...text],
            x,
            y,
            textColor,
            cursorColor,
            highlighColor,
            false,
            false
        )
        currentColumn += text.length + 1
        return [x, y, currentColumn, currentLine]
    }

    const writelnParcel = (
        text,
        textColor = '#0a0',
        cursorColor = '#fff',
        highlighColor = '#0f0',
        cursor = true
    ) => {
        const x = currentColumn * DEFAULT_CHAR_WIDTH
        const y = currentLine * DEFAULT_CHAR_HEIGHT
        drawChars(
            [...text],
            x,
            y,
            textColor,
            cursorColor,
            highlighColor,
            false,
            false
        )
        currentColumn = 1
        currentLine++
        return [x, y, currentColumn, currentLine]
    }

    const printHello = () => {
        const titleLines = welcomeTitle.split('\n')
        const centerOffsetTimes = Math.floor(
            (innerWidth / DEFAULT_CHAR_WIDTH - WELCOMETITLE_LINE_CHARS) / 2
        )

        titleLines.forEach((e, i) => {
            let lineStr = i === 1 || i === 15 ? '='.repeat(centerOffsetTimes) + e + '='.repeat(centerOffsetTimes - 4) : ' '.repeat(centerOffsetTimes) + e
            lineStr = 14 === i ? lineStr + ' Ver ' + VERSION : lineStr
            writelnParcel(lineStr, '#0a0', '#fff', '#abc', false)
        })
    }

    const httpGet = (url) => fetch(url).then((res) => res.json())

    const writeDots = () => {
        write('-')
        requestAnimationFrame(writeDots)
    }

    let cachedIPData = null
    const getIP = () => {
        if (cachedIPData) {
            return Promise.resolve(cachedIPData)
        }
        return httpGet('https://geo.risk3sixty.com/me').then(data => {
            cachedIPData = data
            return data
        })
    }

    const latencyCache = new Map()

    const getMirrorLatency = async (url) => {
        const urlObj = new URL(url)
        const address = `${urlObj.hostname}:${urlObj.port}`

        // 根据当前页面协议选择 HTTP 或 HTTPS
        const protocol = location.protocol === 'https:' ? 'https:' : 'http:'
        const fetchUrl = `${protocol}//${address}/?t=${Math.random()}`
        const start = performance.now()

        try {
            await fetch(fetchUrl, { mode: 'no-cors', cache: 'no-store' })
        } catch (e) {
            // 即使 fetch 报错，TCP 可能已经建立，继续尝试获取 timing
        }

        // 获取性能条目
        const entries = performance.getEntriesByName(fetchUrl)
        if (entries.length > 0) {
            const entry = entries[entries.length - 1]
            // 如果能拿到 connectEnd 和 connectStart，这就是最准的 TCP 握手时间
            if (entry.connectEnd > 0 && entry.connectStart > 0) {
                return Math.round(entry.connectEnd - entry.connectStart)
            }
        }

        // 降级方案：如果拿不到性能数据（因为跨域限制），只能用总耗时
        return Math.round(performance.now() - start)
    }

    //get longest string in array
    const getLongestString = (arr) =>
        arr.reduce((a, b) => (a.length > b.length ? a : b))

    const main = () => {
        CTX.font = '1rem cursive'
        CTX.fillStyle = '#0f0'
        DEFAULT_CHAR_WIDTH = CTX.measureText('M').width

        printHello()
        writeParcel('Local time :')
        writelnParcel(
            ` ${new Intl.DateTimeFormat('en-US', {
                dateStyle: 'full',
                timeStyle: 'long',
            }).format(new Date())}`,
            '#fff',
            '#0f0',
            '#00f',
            false
        )
        const [x, y, c, l] = writeParcel('IP addr :')
        currentColumn = 1
        currentLine++

        getIP().then((ipData) => {
            const ipStr = `${ipData.ip} / ${ipData.country}${ipData.region ? ' / ' + ipData.region : ''}${ipData.city ? ' / ' + ipData.city : ''}`

            _writeText(
                ipStr,
                (DEFAULT_CHAR_WIDTH * c) | 0,
                y | 0,
                '#fff',
                '#0f0',
                '#00f',
                false,
                true
            )

            setTimeout(() => {
                CTX.fillStyle = 'rgba(255, 255, 255, 0.4)'
                CTX.fillRect((DEFAULT_CHAR_WIDTH * c) | 0, y | 0, ipStr.length * DEFAULT_CHAR_WIDTH, DEFAULT_CHAR_HEIGHT)
                setTimeout(() => {
                    CTX.fillStyle = '#000'
                    CTX.fillRect((DEFAULT_CHAR_WIDTH * c) | 0, y | 0, ipStr.length * DEFAULT_CHAR_WIDTH, DEFAULT_CHAR_HEIGHT)

                    CTX.fillStyle = '#fff'
                    CTX.fillText(ipStr, (DEFAULT_CHAR_WIDTH * c) | 0, y + TEXT_BASELINE_OFFSET)
                }, 80)
            }, 200)
        })

        listFetch(getLongestString(Object.keys(MIRROR_LIST)).length)
    }

    const listFetch = (longestLength) => {
        const mirrorEntries = Object.entries(MIRROR_LIST)

        // 记录起始行号
        const startLine = currentLine

        // 先预分配所有行
        mirrorEntries.forEach((m) => {
            const mirrorName = m[0]
            const flagStr = `${' '.repeat(longestLength - mirrorName.length)}${mirrorName}:`

            const x = currentColumn * DEFAULT_CHAR_WIDTH
            const initialY = currentLine * DEFAULT_CHAR_HEIGHT

            // 显示名称
            CTX.fillStyle = '#0f0'
            CTX.fillText(flagStr, x, initialY + TEXT_BASELINE_OFFSET)

            // 计算延迟显示位置
            const usedSpace = (flagStr.length + 12) * DEFAULT_CHAR_WIDTH
            const leftSpace = innerWidth - usedSpace
            const blankBlock = leftSpace / CONTINUOUS_PING_TIMES

            // 预填充占位符
            for (let i = 0; i < CONTINUOUS_PING_TIMES; i++) {
                const px = (usedSpace + blankBlock * i + blankBlock - 12 * DEFAULT_CHAR_WIDTH) | 0
                CTX.fillStyle = '#333'
                CTX.fillText('--', px, initialY + TEXT_BASELINE_OFFSET)
            }

            currentColumn = 1
            currentLine++
        })

        // 然后异步获取延迟数据并更新
        mirrorEntries.forEach((m, index) => {
            const mirrorName = m[0]
            const mirrorUrl = m[1]
            const flagStr = `${' '.repeat(longestLength - mirrorName.length)}${mirrorName}:`

            const startY = (startLine + index) * DEFAULT_CHAR_HEIGHT
            const usedSpace = (flagStr.length + 12) * DEFAULT_CHAR_WIDTH
            const leftSpace = innerWidth - usedSpace
            const blankBlock = leftSpace / CONTINUOUS_PING_TIMES

            // 立即执行第一次延迟（对应第一个位置）
            getMirrorLatency(mirrorUrl).then((timeEscaped) => {
                const latencyColor = getLatencyColor(timeEscaped)
                const px = (usedSpace + blankBlock - 12 * DEFAULT_CHAR_WIDTH) | 0

                CTX.clearRect(px, startY, 8 * DEFAULT_CHAR_WIDTH, DEFAULT_CHAR_HEIGHT)
                CTX.fillStyle = latencyColor
                CTX.fillText(`${timeEscaped}ms`, px, startY + TEXT_BASELINE_OFFSET)
                console.log(`First ping result for ${mirrorName}: ${timeEscaped}ms`)
            }).catch((err) => {
                console.error('First ping error:', err, 'URL:', mirrorUrl)
            })

            // 连续6次延迟
            for (let i = 0; i < CONTINUOUS_PING_TIMES; i++) {
                setTimeout(() => {
                    getMirrorLatency(mirrorUrl).then((timeoutDelayMs) => {
                        const latencyColor = getLatencyColor(timeoutDelayMs)
                        const px = (usedSpace + blankBlock * i + blankBlock - 12 * DEFAULT_CHAR_WIDTH) | 0

                        CTX.clearRect(px, startY, 8 * DEFAULT_CHAR_WIDTH, DEFAULT_CHAR_HEIGHT)
                        CTX.fillStyle = latencyColor
                        CTX.fillText(`${timeoutDelayMs}ms`, px, startY + TEXT_BASELINE_OFFSET)
                    }).catch((err) => {
                        console.error('Ping error:', err)
                    })
                }, (i + 1) * 1000)
            }
        })
    }

    main()
</script>
</body>
</html>